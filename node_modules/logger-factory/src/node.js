/**
 * Module dependencies.
 */
const fs = require('fs');
const path = require('path');
const tty = require('tty');
const util = require('util');
const Common = require('./common.js');

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

module.exports = class State extends Common {
  constructor() {
    super();
    this.prefixColor = 240;
    this.colors = [1, 2, 3, 4, 5, 6, 9, 12, 13, 14, 21,
              28, 34, 39, 40, 52, 58, 88, 124, 129,
              130, 160, 164, 166, 171, 196, 197, 198, 201, 202, 203, 208, 210,
              214];
    this.config = {};
    // $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
    var config = Object.keys(process.env).filter(key => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      // Camel-case
      const prop = key
        .substring(6)
        .toLowerCase()
        .replace(/_([a-z])/g, (_, k) => {
          return k.toUpperCase();
        });

      // Coerce string value into JS value
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === 'null') {
        val = null;
      } else {
        val = Number(val);
      }

      obj[prop] = val;
      return obj;
    }, {
      debug: process.env.debug || process.env.DEBUG
    });
    if (!config.hasOwnProperty('useColors')) {
      config.useColors = tty.isatty(process.stderr.fd);
    }
    config = Object.assign({}, this.defaultConfig, config);
    for (let key in config) {
      this.setConfig(key, config[key]);
    }
    
    this.formatters = {
      /**
       * Map %o to `util.inspect()`, all on a single line.
       */
      o(v) {
        return util.inspect(v, {
          colors: config.colors
        }).replace(/\s*\n\s*/g, ' ');
      },
      /**
       * Map %O to `util.inspect()`, allowing multiple lines if needed.
       */
      O(v) {
        return util.inspect(v, {
          colors: config.colors
        });
      }
    };

    this.lastLogCheckTS = 0;
  }

  get defaultConfig() {
    return Object.assign(super.defaultConfig, {
      toFile: null,
      checkInterval: 3600 * 1000, // check per one hour
      maxSize: 8 * 1024 * 1024 * 1024,  // 8G
      maxCount: 365,  // 365 log files
    });
  }

  /**
   * Load `namespaces`.
   *
   * @return {Object} returns user config
   * @api private
   */
  getConfig() {
    return this.config;
  }
  setConfig(key, value) {
    switch (key) {
      case 'debug':
        this.config[key] = value;
        if (value) {
          process.env.DEBUG = value;
        } else {
          // If you set a process.env field to null or undefined, it gets cast to the
          // string 'null' or 'undefined'. Just delete instead.
          delete process.env.DEBUG;
        }
        this.enable(value);
        break;
      default:
        if (this.defaultConfig.hasOwnProperty(key)) {
          this.config[key] = value;
        }
        break;
    }
  }

  colorWrapper(code) {
    return [`\u001B[38;5;${code}m`, '\u001B[0m'];
  }

  formatArgs(args, {
    namespace = '',
    color = 240
  }) {
    // remove '\n' at end of line, to avoid blank line after split('\n')
    args[0] = args[0].replace(/[\n]* *$/, '');
    const time = this.formatDate(Date.now(), 'hh:mm:ss.SSS');
    // formatDate
    if (this.config.useColors) {
      const prefix = `${this.colorWrapper(this.prefixColor)[0]}${time}${this.colorWrapper(this.prefixColor)[1]} ` + `${this.colorWrapper(color)[0]}${namespace}${this.colorWrapper(color)[1]} `;
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    } else {
      const prefix = `${time} ` + `${namespace} `;
      args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    }
  }

  mkdirPsync(p, opts, made) {
    if (!opts || typeof opts !== 'object') {
      opts = { mode: opts };
    }

    var mode = opts.mode;
    var xfs = opts.fs || fs;

    if (mode === undefined) {
      mode = parseInt('0777', 8) & (~process.umask());
    }
    if (!made) made = null;

    p = path.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    }
    catch (err0) {
      switch (err0.code) {
        case 'ENOENT' :
          made = this.mkdirPsync(path.dirname(p), opts, made);
          this.mkdirPsync(p, opts, made);
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          var stat;
          try {
              stat = xfs.statSync(p);
          }
          catch (err1) {
              throw err0;
          }
          if (!stat.isDirectory()) throw err0;
          break;
      }
    }
    return made;
  }

  escapeRegexp(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }
    return String(str).replace(/([.*+?=^!:${}()|[\]\/\\])/g, '\\$1');
  }
  removeLogIfNecessary(toFile) {
    try {
      const config = this.config;
      if (Date.now() - this.lastLogCheckTS < config.checkInterval) {
        return;
      }
      this.lastLogCheckTS = Date.now();

      const logDir = path.dirname(toFile);
      const fileName = path.basename(toFile);
      if (!logDir || !fs.existsSync(logDir) || !fs.statSync(logDir).isDirectory()) {
        throw new Error(`logDir ${logDir} not exist`);
      }
      const maxSize = config.maxSize ? config.maxSize : 8 * 1024 * 1024 * 1024;
      const maxCount = config.maxCount ? config.maxCount : 365;
      
      const reg = new RegExp(`^${this.escapeRegexp(fileName)}.(\\d{4}-\\d{2}-\\d{2}).log$`);
      const filePathList = fs.readdirSync(logDir).filter(it => reg.test(it)).sort((pre, next) => {
        const preStamp = reg.exec(pre)[1].split('-').join('');
        const nextStamp = reg.exec(next)[1].split('-').join('');
        return parseInt(preStamp) - parseInt(nextStamp);
      }).map(it => path.resolve(logDir, it));
      if (filePathList.length === 0) {
        return;
      }

      var fileStatList = filePathList.map(it => fs.statSync(it));
      var totalSize = fileStatList.reduce((sum, it) => {
        sum += it.size;
        return sum;
      }, 0);
      while ((totalSize > maxSize || filePathList.length > maxCount) && filePathList.length > 1) {
        let filePath = filePathList.shift();
        let stat = fileStatList.shift(); // NOTICE: not used
        fs.unlinkSync(filePath)
        totalSize = fileStatList.reduce((sum, it) => {
          sum += it.size;
          return sum;
        }, 0);
      }
    } catch (err) {
      console.log(err);
    }
  }

  /**
   * Invokes `util.format()` with the specified arguments and writes to stderr.
   */
  log(args, {
    namespace = '',
    toFile = null
  }) {
    !toFile && (toFile = this.config.toFile);
    if (toFile) {
      var filePath = `${toFile}.${this.formatDate(Date.now(), 'yyyy-MM-dd')}.log`;
      var line = util.format(...args) + '\n';
      if (!fs.existsSync(filePath)) {
        this.mkdirPsync(path.dirname(filePath));
        fs.writeFileSync(filePath, line);
      } else {
        // line after process.exit will not write if fs.appendFile is used
        fs.appendFileSync(filePath, line, function() {})
      }
      this.removeLogIfNecessary(toFile);
    } else {
      return process.stdout.write(util.format(...args) + '\n');
    }
  }
}
